## 秒杀服务端
### 简介
这是一个简单的商品秒杀服务端，通过redis实现快速读写库存，实现以商品粒度的分布式锁来防止并发操作库存的问题。秒杀成功的订单以消息的模式发送到mq上，然后可以在商品服务中消费这个mq来创建订单落库，消费者这一块这个项目中没有实现。
### 秒杀流程
1. 通过拦截器每秒放一部分请求进来进行抢购，过滤的请求直接返回抢购失败。
2. 进行抢购数量，活动，商品是否售罄等基本的校验
3. 尝试扣库存。
    1. 尝试请求获取该商品的锁
    2. 获取该商品的库存，如果库存为0，则加到售罄队列，返回抢购失败
    3. 扣减库存
    4. 生成订单发送mq
    5. 抢购成功，返回订单号
### 主要接口
+ /seckill/init 初始化秒杀活动信息。预设活动信息，商品库存信息。每次压测前都要删除redis数据，重新调这个接口初始化数据。
+ /seckill/order 秒杀接口
### 总结
秒杀系统是非常复杂的，这里只是模拟了服务端的工作流程，并没有涉及到前端、负载均衡等的部分。高并发的思想就是避免频繁的读写数据库IO操作，利用mq来异步生成订单，并且要保证不能超卖。
+ 以商品维度生成分布式锁，可以支持多个不同商品的抢购活动。
+ 请求过滤（接口限流）。抢购本来就是一个概率事件，1000个商品，100万人抢购，千分之一的成功率，总不能把这100万个请求都去redis库存查一遍吧，那样redis也扛不住，所以随机丢弃部分请求是巧妙且合理的。这里就是为秒杀接口配置一个限流的拦截器来过滤请求。
+ 预防超卖。关于扣库存和发送mq，应该是先扣库存，后发送mq，因为发送mq有可能会失败，mq里面的订单一定是扣减过库存的，不会超卖。有人说这里通过mq的结果来判断扣减redis库存，或者发送mq失败再把库存加回去，其实没必要，少买总比超卖好。其实mq的可靠性还是很高的，我测试了很多次百万级别的并发请求，还没有出现少买的情况。